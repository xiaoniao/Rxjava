<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="zh">
<head>
<!-- Generated by javadoc (1.8.0_77) on Wed Aug 10 15:37:31 CST 2016 -->
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>BackpressureUtils</title>
<meta name="date" content="2016-08-10">
<link rel="stylesheet" type="text/css" href="../../../stylesheet.css" title="Style">
<script type="text/javascript" src="../../../script.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="BackpressureUtils";
        }
    }
    catch(err) {
    }
//-->
var methods = {"i0":9,"i1":41,"i2":9,"i3":9,"i4":9,"i5":9,"i6":9,"i7":9,"i8":9,"i9":9};
var tabs = {65535:["t0","所有方法"],1:["t1","静态方法"],8:["t4","具体方法"],32:["t6","已过时的方法"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
</script>
<noscript>
<div>您的浏览器已禁用 JavaScript。</div>
</noscript>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a name="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="跳过导航链接">跳过导航链接</a></div>
<a name="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="导航">
<li><a href="../../../overview-summary.html">概览</a></li>
<li><a href="package-summary.html">程序包</a></li>
<li class="navBarCell1Rev">类</li>
<li><a href="class-use/BackpressureUtils.html">使用</a></li>
<li><a href="package-tree.html">树</a></li>
<li><a href="../../../deprecated-list.html">已过时</a></li>
<li><a href="../../../index-files/index-1.html">索引</a></li>
<li><a href="../../../help-doc.html">帮助</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li>上一个类</li>
<li><a href="../../../rx/internal/operators/BlockingOperatorLatest.html" title="rx.internal.operators中的类"><span class="typeNameLink">下一个类</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../../index.html?rx/internal/operators/BackpressureUtils.html" target="_top">框架</a></li>
<li><a href="BackpressureUtils.html" target="_top">无框架</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../../allclasses-noframe.html">所有类</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>概要:&nbsp;</li>
<li>嵌套&nbsp;|&nbsp;</li>
<li>字段&nbsp;|&nbsp;</li>
<li>构造器&nbsp;|&nbsp;</li>
<li><a href="#method.summary">方法</a></li>
</ul>
<ul class="subNavList">
<li>详细资料:&nbsp;</li>
<li>字段&nbsp;|&nbsp;</li>
<li>构造器&nbsp;|&nbsp;</li>
<li><a href="#method.detail">方法</a></li>
</ul>
</div>
<a name="skip.navbar.top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="subTitle">rx.internal.operators</div>
<h2 title="类 BackpressureUtils" class="title">类 BackpressureUtils</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
<li>java.lang.Object</li>
<li>
<ul class="inheritance">
<li>rx.internal.operators.BackpressureUtils</li>
</ul>
</li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<hr>
<br>
<pre>public final class <span class="typeNameLabel">BackpressureUtils</span>
extends java.lang.Object</pre>
<div class="block">Utility functions for use with backpressure.</div>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method.summary">
<!--   -->
</a>
<h3>方法概要</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="方法概要表, 列表方法和解释">
<caption><span id="t0" class="activeTableTab"><span>所有方法</span><span class="tabEnd">&nbsp;</span></span><span id="t1" class="tableTab"><span><a href="javascript:show(1);">静态方法</a></span><span class="tabEnd">&nbsp;</span></span><span id="t4" class="tableTab"><span><a href="javascript:show(8);">具体方法</a></span><span class="tabEnd">&nbsp;</span></span><span id="t6" class="tableTab"><span><a href="javascript:show(32);">已过时的方法</a></span><span class="tabEnd">&nbsp;</span></span></caption>
<tr>
<th class="colFirst" scope="col">限定符和类型</th>
<th class="colLast" scope="col">方法和说明</th>
</tr>
<tr id="i0" class="altColor">
<td class="colFirst"><code>static long</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../rx/internal/operators/BackpressureUtils.html#addCap-long-long-">addCap</a></span>(long&nbsp;a,
      long&nbsp;b)</code>
<div class="block">Adds two positive longs and caps the result at Long.MAX_VALUE.</div>
</td>
</tr>
<tr id="i1" class="rowColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;long</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../rx/internal/operators/BackpressureUtils.html#getAndAddRequest-java.util.concurrent.atomic.AtomicLongFieldUpdater-T-long-">getAndAddRequest</a></span>(java.util.concurrent.atomic.AtomicLongFieldUpdater&lt;T&gt;&nbsp;requested,
                T&nbsp;object,
                long&nbsp;n)</code>
<div class="block"><span class="deprecatedLabel">已过时。</span>&nbsp;
<div class="block"><span class="deprecationComment">Android has issues with reflection-based atomics</span></div>
</div>
</td>
</tr>
<tr id="i2" class="altColor">
<td class="colFirst"><code>static long</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../rx/internal/operators/BackpressureUtils.html#getAndAddRequest-java.util.concurrent.atomic.AtomicLong-long-">getAndAddRequest</a></span>(java.util.concurrent.atomic.AtomicLong&nbsp;requested,
                long&nbsp;n)</code>
<div class="block">Adds <code>n</code> (not validated) to <code>requested</code> and returns the value prior to addition once the
 addition is successful (uses CAS semantics).</div>
</td>
</tr>
<tr id="i3" class="rowColor">
<td class="colFirst"><code>static long</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../rx/internal/operators/BackpressureUtils.html#multiplyCap-long-long-">multiplyCap</a></span>(long&nbsp;a,
           long&nbsp;b)</code>
<div class="block">Multiplies two positive longs and caps the result at Long.MAX_VALUE.</div>
</td>
</tr>
<tr id="i4" class="altColor">
<td class="colFirst"><code>static &lt;T,R&gt;&nbsp;void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../rx/internal/operators/BackpressureUtils.html#postCompleteDone-java.util.concurrent.atomic.AtomicLong-java.util.Queue-rx.Subscriber-rx.functions.Func1-">postCompleteDone</a></span>(java.util.concurrent.atomic.AtomicLong&nbsp;requested,
                java.util.Queue&lt;T&gt;&nbsp;queue,
                <a href="../../../rx/Subscriber.html" title="rx中的类">Subscriber</a>&lt;? super R&gt;&nbsp;actual,
                <a href="../../../rx/functions/Func1.html" title="rx.functions中的接口">Func1</a>&lt;? super T,? extends R&gt;&nbsp;exitTransform)</code>
<div class="block">Signals the completion of the main sequence and switches to post-completion replay mode
 and allows exit transformation on the queued values.</div>
</td>
</tr>
<tr id="i5" class="rowColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../rx/internal/operators/BackpressureUtils.html#postCompleteDone-java.util.concurrent.atomic.AtomicLong-java.util.Queue-rx.Subscriber-">postCompleteDone</a></span>(java.util.concurrent.atomic.AtomicLong&nbsp;requested,
                java.util.Queue&lt;T&gt;&nbsp;queue,
                <a href="../../../rx/Subscriber.html" title="rx中的类">Subscriber</a>&lt;? super T&gt;&nbsp;actual)</code>
<div class="block">Signals the completion of the main sequence and switches to post-completion replay mode.</div>
</td>
</tr>
<tr id="i6" class="altColor">
<td class="colFirst"><code>static &lt;T,R&gt;&nbsp;boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../rx/internal/operators/BackpressureUtils.html#postCompleteRequest-java.util.concurrent.atomic.AtomicLong-long-java.util.Queue-rx.Subscriber-rx.functions.Func1-">postCompleteRequest</a></span>(java.util.concurrent.atomic.AtomicLong&nbsp;requested,
                   long&nbsp;n,
                   java.util.Queue&lt;T&gt;&nbsp;queue,
                   <a href="../../../rx/Subscriber.html" title="rx中的类">Subscriber</a>&lt;? super R&gt;&nbsp;actual,
                   <a href="../../../rx/functions/Func1.html" title="rx.functions中的接口">Func1</a>&lt;? super T,? extends R&gt;&nbsp;exitTransform)</code>
<div class="block">Accumulates requests (validated) and handles the completed mode draining of the queue based on the requests
 and allows exit transformation on the queued values.</div>
</td>
</tr>
<tr id="i7" class="rowColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../rx/internal/operators/BackpressureUtils.html#postCompleteRequest-java.util.concurrent.atomic.AtomicLong-long-java.util.Queue-rx.Subscriber-">postCompleteRequest</a></span>(java.util.concurrent.atomic.AtomicLong&nbsp;requested,
                   long&nbsp;n,
                   java.util.Queue&lt;T&gt;&nbsp;queue,
                   <a href="../../../rx/Subscriber.html" title="rx中的类">Subscriber</a>&lt;? super T&gt;&nbsp;actual)</code>
<div class="block">Accumulates requests (validated) and handles the completed mode draining of the queue based on the requests.</div>
</td>
</tr>
<tr id="i8" class="altColor">
<td class="colFirst"><code>static long</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../rx/internal/operators/BackpressureUtils.html#produced-java.util.concurrent.atomic.AtomicLong-long-">produced</a></span>(java.util.concurrent.atomic.AtomicLong&nbsp;requested,
        long&nbsp;n)</code>
<div class="block">Atomically subtracts a value from the requested amount unless it's at Long.MAX_VALUE.</div>
</td>
</tr>
<tr id="i9" class="rowColor">
<td class="colFirst"><code>static boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../rx/internal/operators/BackpressureUtils.html#validate-long-">validate</a></span>(long&nbsp;n)</code>
<div class="block">Validates the requested amount and returns true if it is positive.</div>
</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a name="methods.inherited.from.class.java.lang.Object">
<!--   -->
</a>
<h3>从类继承的方法&nbsp;java.lang.Object</h3>
<code>equals, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method.detail">
<!--   -->
</a>
<h3>方法详细资料</h3>
<a name="getAndAddRequest-java.util.concurrent.atomic.AtomicLongFieldUpdater-java.lang.Object-long-">
<!--   -->
</a><a name="getAndAddRequest-java.util.concurrent.atomic.AtomicLongFieldUpdater-T-long-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getAndAddRequest</h4>
<pre>@Deprecated
public static&nbsp;&lt;T&gt;&nbsp;long&nbsp;getAndAddRequest(java.util.concurrent.atomic.AtomicLongFieldUpdater&lt;T&gt;&nbsp;requested,
                                                     T&nbsp;object,
                                                     long&nbsp;n)</pre>
<div class="block"><span class="deprecatedLabel">已过时。</span>&nbsp;<span class="deprecationComment">Android has issues with reflection-based atomics</span></div>
<div class="block">Adds <code>n</code> to <code>requested</code> field and returns the value prior to
 addition once the addition is successful (uses CAS semantics). If
 overflows then sets <code>requested</code> field to <code>Long.MAX_VALUE</code>.</div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>T</code> - the type of the target object on which the field updater operates</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>requested</code> - atomic field updater for a request count</dd>
<dd><code>object</code> - contains the field updated by the updater</dd>
<dd><code>n</code> - the number of requests to add to the requested count</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>requested value just prior to successful addition</dd>
</dl>
</li>
</ul>
<a name="getAndAddRequest-java.util.concurrent.atomic.AtomicLong-long-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getAndAddRequest</h4>
<pre>public static&nbsp;long&nbsp;getAndAddRequest(java.util.concurrent.atomic.AtomicLong&nbsp;requested,
                                    long&nbsp;n)</pre>
<div class="block">Adds <code>n</code> (not validated) to <code>requested</code> and returns the value prior to addition once the
 addition is successful (uses CAS semantics). If overflows then sets
 <code>requested</code> field to <code>Long.MAX_VALUE</code>.</div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>requested</code> - atomic long that should be updated</dd>
<dd><code>n</code> - the number of requests to add to the requested count, positive (not validated)</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>requested value just prior to successful addition</dd>
</dl>
</li>
</ul>
<a name="multiplyCap-long-long-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>multiplyCap</h4>
<pre>public static&nbsp;long&nbsp;multiplyCap(long&nbsp;a,
                               long&nbsp;b)</pre>
<div class="block">Multiplies two positive longs and caps the result at Long.MAX_VALUE.</div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>a</code> - the first value</dd>
<dd><code>b</code> - the second value</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>the capped product of a and b</dd>
</dl>
</li>
</ul>
<a name="addCap-long-long-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>addCap</h4>
<pre>public static&nbsp;long&nbsp;addCap(long&nbsp;a,
                          long&nbsp;b)</pre>
<div class="block">Adds two positive longs and caps the result at Long.MAX_VALUE.</div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>a</code> - the first value</dd>
<dd><code>b</code> - the second value</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>the capped sum of a and b</dd>
</dl>
</li>
</ul>
<a name="postCompleteDone-java.util.concurrent.atomic.AtomicLong-java.util.Queue-rx.Subscriber-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>postCompleteDone</h4>
<pre>public static&nbsp;&lt;T&gt;&nbsp;void&nbsp;postCompleteDone(java.util.concurrent.atomic.AtomicLong&nbsp;requested,
                                        java.util.Queue&lt;T&gt;&nbsp;queue,
                                        <a href="../../../rx/Subscriber.html" title="rx中的类">Subscriber</a>&lt;? super T&gt;&nbsp;actual)</pre>
<div class="block">Signals the completion of the main sequence and switches to post-completion replay mode.
 
 <p>
 Don't modify the queue after calling this method!
 
 <p>
 Post-completion backpressure handles the case when a source produces values based on
 requests when it is active but more values are available even after its completion.
 In this case, the onCompleted() can't just emit the contents of the queue but has to
 coordinate with the requested amounts. This requires two distinct modes: active and
 completed. In active mode, requests flow through and the queue is not accessed but
 in completed mode, requests no-longer reach the upstream but help in draining the queue.
 <p>
 The algorithm utilizes the most significant bit (bit 63) of a long value (AtomicLong) since
 request amount only goes up to Long.MAX_VALUE (bits 0-62) and negative values aren't
 allowed.</div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>T</code> - the value type to emit</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>requested</code> - the holder of current requested amount</dd>
<dd><code>queue</code> - the queue holding values to be emitted after completion</dd>
<dd><code>actual</code> - the subscriber to receive the values</dd>
</dl>
</li>
</ul>
<a name="postCompleteRequest-java.util.concurrent.atomic.AtomicLong-long-java.util.Queue-rx.Subscriber-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>postCompleteRequest</h4>
<pre>public static&nbsp;&lt;T&gt;&nbsp;boolean&nbsp;postCompleteRequest(java.util.concurrent.atomic.AtomicLong&nbsp;requested,
                                              long&nbsp;n,
                                              java.util.Queue&lt;T&gt;&nbsp;queue,
                                              <a href="../../../rx/Subscriber.html" title="rx中的类">Subscriber</a>&lt;? super T&gt;&nbsp;actual)</pre>
<div class="block">Accumulates requests (validated) and handles the completed mode draining of the queue based on the requests.
 
 <p>
 Post-completion backpressure handles the case when a source produces values based on
 requests when it is active but more values are available even after its completion.
 In this case, the onCompleted() can't just emit the contents of the queue but has to
 coordinate with the requested amounts. This requires two distinct modes: active and
 completed. In active mode, requests flow through and the queue is not accessed but
 in completed mode, requests no-longer reach the upstream but help in draining the queue.</div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>T</code> - the value type to emit</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>requested</code> - the holder of current requested amount</dd>
<dd><code>n</code> - the value requested;</dd>
<dd><code>queue</code> - the queue holding values to be emitted after completion</dd>
<dd><code>actual</code> - the subscriber to receive the values</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>true if in the active mode and the request amount of n can be relayed to upstream, false if
 in the post-completed mode and the queue is draining.</dd>
</dl>
</li>
</ul>
<a name="postCompleteDone-java.util.concurrent.atomic.AtomicLong-java.util.Queue-rx.Subscriber-rx.functions.Func1-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>postCompleteDone</h4>
<pre>public static&nbsp;&lt;T,R&gt;&nbsp;void&nbsp;postCompleteDone(java.util.concurrent.atomic.AtomicLong&nbsp;requested,
                                          java.util.Queue&lt;T&gt;&nbsp;queue,
                                          <a href="../../../rx/Subscriber.html" title="rx中的类">Subscriber</a>&lt;? super R&gt;&nbsp;actual,
                                          <a href="../../../rx/functions/Func1.html" title="rx.functions中的接口">Func1</a>&lt;? super T,? extends R&gt;&nbsp;exitTransform)</pre>
<div class="block">Signals the completion of the main sequence and switches to post-completion replay mode
 and allows exit transformation on the queued values.
 
 <p>
 Don't modify the queue after calling this method!
 
 <p>
 Post-completion backpressure handles the case when a source produces values based on
 requests when it is active but more values are available even after its completion.
 In this case, the onCompleted() can't just emit the contents of the queue but has to
 coordinate with the requested amounts. This requires two distinct modes: active and
 completed. In active mode, requests flow through and the queue is not accessed but
 in completed mode, requests no-longer reach the upstream but help in draining the queue.
 <p>
 The algorithm utilizes the most significant bit (bit 63) of a long value (AtomicLong) since
 request amount only goes up to Long.MAX_VALUE (bits 0-62) and negative values aren't
 allowed.</div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>T</code> - the value type in the queue</dd>
<dd><code>R</code> - the value type to emit</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>requested</code> - the holder of current requested amount</dd>
<dd><code>queue</code> - the queue holding values to be emitted after completion</dd>
<dd><code>actual</code> - the subscriber to receive the values</dd>
<dd><code>exitTransform</code> - the transformation to apply on the dequeued value to get the value to be emitted</dd>
</dl>
</li>
</ul>
<a name="postCompleteRequest-java.util.concurrent.atomic.AtomicLong-long-java.util.Queue-rx.Subscriber-rx.functions.Func1-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>postCompleteRequest</h4>
<pre>public static&nbsp;&lt;T,R&gt;&nbsp;boolean&nbsp;postCompleteRequest(java.util.concurrent.atomic.AtomicLong&nbsp;requested,
                                                long&nbsp;n,
                                                java.util.Queue&lt;T&gt;&nbsp;queue,
                                                <a href="../../../rx/Subscriber.html" title="rx中的类">Subscriber</a>&lt;? super R&gt;&nbsp;actual,
                                                <a href="../../../rx/functions/Func1.html" title="rx.functions中的接口">Func1</a>&lt;? super T,? extends R&gt;&nbsp;exitTransform)</pre>
<div class="block">Accumulates requests (validated) and handles the completed mode draining of the queue based on the requests
 and allows exit transformation on the queued values.
 
 <p>
 Post-completion backpressure handles the case when a source produces values based on
 requests when it is active but more values are available even after its completion.
 In this case, the onCompleted() can't just emit the contents of the queue but has to
 coordinate with the requested amounts. This requires two distinct modes: active and
 completed. In active mode, requests flow through and the queue is not accessed but
 in completed mode, requests no-longer reach the upstream but help in draining the queue.</div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>T</code> - the value type in the queue</dd>
<dd><code>R</code> - the value type to emit</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>requested</code> - the holder of current requested amount</dd>
<dd><code>n</code> - the value requested;</dd>
<dd><code>queue</code> - the queue holding values to be emitted after completion</dd>
<dd><code>actual</code> - the subscriber to receive the values</dd>
<dd><code>exitTransform</code> - the transformation to apply on the dequeued value to get the value to be emitted</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>true if in the active mode and the request amount of n can be relayed to upstream, false if
 in the post-completed mode and the queue is draining.</dd>
</dl>
</li>
</ul>
<a name="produced-java.util.concurrent.atomic.AtomicLong-long-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>produced</h4>
<pre>public static&nbsp;long&nbsp;produced(java.util.concurrent.atomic.AtomicLong&nbsp;requested,
                            long&nbsp;n)</pre>
<div class="block">Atomically subtracts a value from the requested amount unless it's at Long.MAX_VALUE.</div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>requested</code> - the requested amount holder</dd>
<dd><code>n</code> - the value to subtract from the requested amount, has to be positive (not verified)</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>the new requested amount</dd>
<dt><span class="throwsLabel">抛出:</span></dt>
<dd><code>java.lang.IllegalStateException</code> - if n is greater than the current requested amount, which
 indicates a bug in the request accounting logic</dd>
</dl>
</li>
</ul>
<a name="validate-long-">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>validate</h4>
<pre>public static&nbsp;boolean&nbsp;validate(long&nbsp;n)</pre>
<div class="block">Validates the requested amount and returns true if it is positive.</div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>n</code> - the requested amount</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>true if n is positive</dd>
<dt><span class="throwsLabel">抛出:</span></dt>
<dd><code>java.lang.IllegalArgumentException</code> - if n is negative</dd>
</dl>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<!-- ========= END OF CLASS DATA ========= -->
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a name="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="跳过导航链接">跳过导航链接</a></div>
<a name="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="导航">
<li><a href="../../../overview-summary.html">概览</a></li>
<li><a href="package-summary.html">程序包</a></li>
<li class="navBarCell1Rev">类</li>
<li><a href="class-use/BackpressureUtils.html">使用</a></li>
<li><a href="package-tree.html">树</a></li>
<li><a href="../../../deprecated-list.html">已过时</a></li>
<li><a href="../../../index-files/index-1.html">索引</a></li>
<li><a href="../../../help-doc.html">帮助</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li>上一个类</li>
<li><a href="../../../rx/internal/operators/BlockingOperatorLatest.html" title="rx.internal.operators中的类"><span class="typeNameLink">下一个类</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../../index.html?rx/internal/operators/BackpressureUtils.html" target="_top">框架</a></li>
<li><a href="BackpressureUtils.html" target="_top">无框架</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../../allclasses-noframe.html">所有类</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>概要:&nbsp;</li>
<li>嵌套&nbsp;|&nbsp;</li>
<li>字段&nbsp;|&nbsp;</li>
<li>构造器&nbsp;|&nbsp;</li>
<li><a href="#method.summary">方法</a></li>
</ul>
<ul class="subNavList">
<li>详细资料:&nbsp;</li>
<li>字段&nbsp;|&nbsp;</li>
<li>构造器&nbsp;|&nbsp;</li>
<li><a href="#method.detail">方法</a></li>
</ul>
</div>
<a name="skip.navbar.bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</body>
</html>
